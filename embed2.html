<!doctype html>
<html lang="ja">
<head><!-- --- EMBED: session受信 + 高さ通知 + overflow:hidden --- -->
<style>
  /* embed 側ではスクロールを出さない */
  html, body { height:150%; margin:0; padding:0; overflow:hidden; }
  /* wrapper (UI) が長くなっても親側で高さを合わせるので内部スクロールは不要 */
  .wrap{ overflow:visible; }

  /* --- 追加: ビューポートに合わせて縮小表示するためのラッパー（デザインそのまま維持） --- */
  .fit-viewport-container{
    width:100%;
    height:100%;
    display:flex;
    justify-content:center; /* 横中央寄せ（見た目を変えない） */
    align-items:flex-start;  /* 上寄せして元の top レイアウトを維持 */
    overflow:hidden;
    box-sizing:border-box;
    padding:18px 0; /* 元の body margin と整合 */
  }
  /* .wrap 自体の既存スタイルは変更しない（max-width 等を維持） */
  .fit-viewport-container > .wrap {
    transform-origin: top center;
    transition: transform 160ms linear;
    will-change: transform;
  }
</style>

<script type="module">
/* supabase client が既に window.supabase にあることを前提。
   もしない場合は最上部で createClient するコードを追加してください。 */

const TARGET_ORIGIN = location.origin || '*'

// utility: send message to parent
function postToParent(msg){
  try{
    window.parent.postMessage(msg, TARGET_ORIGIN)
  }catch(e){
    try{ window.parent.postMessage(msg, '*') }catch(e2){ console.warn('postToParent failed', e2) }
  }
}

// report ready to host so it can send session
function reportReady(){
  postToParent({ type: 'child_ready', url: location.href })
  console.log('embed: child_ready sent')
}

// expose loadRemoteFor to global if not already (the function must exist in your main embed logic)
if(typeof window.loadRemoteFor !== 'function'){
  // stub — if your embed has a loader, replace this
  window.loadRemoteFor = async function(uid){
    console.log('loadRemoteFor not implemented - uid:', uid)
    // If your main script defines a different loader, ignore this stub.
  }
}

// receive messages from parent
window.addEventListener('message', async (ev) => {
  try{
    // accept same-origin messages; if origin differs, still accept if structure is ok (but warn)
    if(ev.origin !== location.origin){
      console.warn('embed: message origin mismatch', ev.origin, 'expected', location.origin)
      // continue (for cross-origin testing); in production prefer same-origin
    }
  }catch(e){ console.warn(e) }

  const msg = ev.data
  if(!msg || typeof msg !== 'object') return

  if(msg.type === 'supabase_session' && msg.session){
    console.log('embed: received session from host')
    try{
      if(window.supabase && typeof window.supabase.auth?.setSession === 'function'){
        await window.supabase.auth.setSession({ access_token: msg.session.access_token, refresh_token: msg.session.refresh_token })
        console.log('embed: supabase session set')
        // now load user data
        const uid = msg.session.user?.id
        if(uid && typeof window.loadRemoteFor === 'function'){
          try{ await window.loadRemoteFor(uid); console.log('embed: loaded remote data for', uid) }catch(e){ console.warn('embed loadRemoteFor error', e) }
        }
      } else {
        console.warn('embed: supabase client or setSession not available')
      }
    }catch(e){ console.warn('embed setSession error', e) }
  } else if(msg.type === 'signout'){
    if(window.supabase && typeof window.supabase.auth?.signOut === 'function'){
      try{ await window.supabase.auth.signOut(); console.log('embed: signed out'); }catch(e){ console.warn(e) }
    }
  }
})

// HEIGHT reporting: robust notification of content height
function reportHeightToParent(){
  try{
    const body = document.body, html = document.documentElement
    const height = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight)
    postToParent({ type:'child_height', height })
  }catch(e){ console.warn('reportHeightToParent err', e) }
}

// observe size/content changes
const ro = new ResizeObserver(entries => {
  reportHeightToParent()
})
ro.observe(document.documentElement)
ro.observe(document.body)

const mo = new MutationObserver(() => { setTimeout(reportHeightToParent, 40) })
mo.observe(document.body, { childList:true, subtree:true, attributes:true })

// initial ready + height report after load
window.addEventListener('load', ()=>{ reportReady(); setTimeout(reportHeightToParent, 120) })

// also immediately announce ready in case parent loaded after
setTimeout(reportReady, 300)

// allow manual debug post
window.reportHeightToParent = reportHeightToParent
window.postLogToParent = msg => postToParent({ type:'child_log', msg })

</script>

<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>学習実態調査（認証付き・修正版）</title>
<style>
:root{
  --bg:#f6f8fb; --card:#fff; --muted:#6b7280; --accent:#4461f2; --radius:12px;
}
*{box-sizing:border-box}
body{font-family:Inter,system-ui,'Noto Sans JP',sans-serif;background:var(--bg);margin:18px;color:#0f1724}
.wrap{max-width:1100px;margin:0 auto}
.card{background:var(--card);border-radius:var(--radius);padding:12px;box-shadow:0 10px 30px rgba(16,24,40,0.06)}
.top{display:flex;gap:12px;align-items:flex-start;margin-bottom:12px}
.small{font-size:13px;color:var(--muted)}
.palette{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
.subject-btn{display:flex;align-items:center;gap:8px;padding:8px 12px;border-radius:999px;color:#fff;font-weight:700;cursor:pointer;border:0}
.grid-wrap{overflow:auto;margin-top:12px}
.hours-grid{display:grid;grid-auto-flow:column;grid-auto-columns:minmax(72px,1fr);padding:12px}
.hour-col{min-width:72px;padding:6px}
.hour-header{font-size:12px;color:var(--muted);text-align:center;margin-bottom:6px}
.hour-cell{height:72px;border-radius:10px;border:1px solid rgba(16,24,40,0.04);position:relative;overflow:hidden;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#fff,#fbfbff)}
.segments{display:flex;height:100%;width:100%}
.segment{flex:1;position:relative}
.fill{position:absolute;left:0;top:0;bottom:0;width:0;transition:width .2s linear}
.overlay{position:absolute;left:0;right:0;bottom:6px;text-align:center;font-weight:700;color:rgba(0,0,0,0.65);z-index:3}
.cell-label{position:absolute;left:6px;top:6px;font-weight:700;color:rgba(0,0,0,0.75);z-index:4}
.legend{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px;align-items:center}
.legend .item{display:flex;align-items:center;gap:8px}
.legend input[type="color"]{border:0;padding:0;width:34px;height:28px;border-radius:6px}
.btn{background:var(--accent);color:#fff;padding:8px 12px;border-radius:10px;border:0;cursor:pointer;font-weight:700}
.btn.ghost{background:transparent;color:var(--accent);border:1px solid rgba(68,97,242,0.12)}
.auth-card{min-width:260px;display:flex;flex-direction:column;gap:8px}
.compact-day{background:#fff;border-radius:10px;padding:8px;border:1px solid rgba(0,0,0,0.04);margin-top:8px}
.compact-grid{display:grid;grid-auto-flow:column;grid-auto-columns:minmax(48px,1fr);gap:6px;align-items:start}
.compact-hour{min-width:48px}
.compact-cell{height:44px;border-radius:8px;border:1px solid rgba(16,24,40,0.04);position:relative;overflow:hidden}
.small-muted{font-size:12px;color:var(--muted)}
.add-subject{display:flex;gap:8px;margin-top:8px;align-items:center}
.graph-card{margin-top:10px}
@media(max-width:900px){.hour-cell{height:56px}}
</style>
</head>
<body>

<!-- ここで既存の .wrap を内包し、デザインは一切変更せずにフィット処理だけ追加 -->
<div class="fit-viewport-container">
  <div class="wrap">
    <h1>デジタル版学習実態調査</h1>

    <div class="top">
      <div class="card" style="min-width:480px">
        <div style="display:flex;gap:12px;align-items:center">
          <div><div class="small">日付</div><input type="date" id="dateInput"></div>
          <div><div class="small">開始時刻</div><input type="time" id="startTimeInput"></div>
          <div style="margin-left:8px"><div class="small">操作</div>
            <div style="display:flex;gap:8px;margin-top:6px">
              <button id="startBtn" class="btn">開始</button>
              <button id="pauseBtn" class="btn ghost">一時停止</button>
              <button id="resetBtn" class="btn ghost">リセット</button>
              <button id="setNowBtn" class="btn ghost">今に</button>
            </div>
          </div>
        </div>
        <div style="display:flex;gap:16px;margin-top:10px;align-items:center">
          <div class="small">経過（セッション）<div id="elapsedLabel" style="font-weight:800">00:00:00</div></div>
          <div class="small">今日合計<div id="todayTotalLabel" style="font-weight:800">0:00:00</div></div>
        </div>
      </div>

      <div style="flex:1"></div>

      <div class="card auth-card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div style="font-weight:700">アカウント</div>
          <div id="authControls"></div>
        </div>
        <div id="authStatus" class="small-muted">状態: 未確認</div>
        <div class="small-muted" style="margin-top:6px">※サインアップ時に役割（teacher / student）を指定</div>
      </div>

      <div class="card" style="min-width:360px">
        <div class="small">教科パレット（選択してから開始）</div>
        <div id="palette" class="palette"></div>
        <div id="legend" class="legend"></div>

        <div class="add-subject">
          <input id="newSubjectName" placeholder="新しい教科名" style="padding:8px;border-radius:8px;border:1px solid #e5e7eb;flex:1" />
          <input id="newSubjectColor" type="color" value="#7c3aed" />
          <button id="addSubjectBtn" class="btn">追加</button>
        </div>

        <div class="small" style="margin-top:8px">直近1週間</div>
        <div id="weeklyList" class="small" style="margin-top:6px"></div>
        <div id="weeklyTotalBox" style="display:none;margin-top:8px" class="small"><strong>週合計:</strong> <span id="weeklyTotalLabel">0:00:00</span></div>

        <div id="openedDays"></div>

        <div class="card graph-card" style="margin-top:10px;padding:10px">
          <div class="small">日別合計（折れ線）</div>
          <div id="weeklyChart" style="width:100%;height:160px;margin-top:8px"></div>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="small">時間表示と塗り</div>
      <div class="grid-wrap"><div id="hoursGrid" class="hours-grid"></div></div>
    </div>
  </div>
</div>
<!-- /.fit-viewport-container -->

<script type="module">
/* --------------------------
   Supabase setup
   -------------------------- */
import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm'
const SUPABASE_URL = 'https://pscowkpzgomszpvjtnge.supabase.co'
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBzY293a3B6Z29tc3pwdmp0bmdlIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA0MjIwNTUsImV4cCI6MjA3NTk5ODA1NX0.CVRZM4e-vXxGWzLCK6aOIANJjQ0NpVwSuTfTeQbvQg0'
const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY)
window.supabase = supabase
  // --- 即時セッション復元 & セッション維持 (追加) ---
// 置く場所: createClient(...); window.supabase = supabase の直後に挿入してください。

const _SESSION_KEY = 'supabase_session_v2'; // 既存と同じキーを参照

// 1) ページ読み込み直後に localStorage の保存済みトークンで即時復元を試みる
;(async function immediateRestore(){
  try{
    const raw = localStorage.getItem(_SESSION_KEY);
    if(!raw) { console.log('immediateRestore: no saved session'); return; }
    const saved = JSON.parse(raw);
    if(saved?.access_token && saved?.refresh_token){
      console.log('immediateRestore: trying setSession from localStorage');
      const { data, error } = await supabase.auth.setSession({
        access_token: saved.access_token,
        refresh_token: saved.refresh_token
      });
      if(error){
        console.warn('immediateRestore: setSession error (clearing saved):', error);
        // もし無効なら保存をクリアしておく
        try{ localStorage.removeItem(_SESSION_KEY); }catch(e){}
      } else {
        console.log('immediateRestore: session restored from localStorage', data?.session?.user?.email || data?.session?.user?.id || '');
      }
    }
  }catch(e){
    console.warn('immediateRestore err', e);
  }
})();

// 2) 定期的にセッションをチェックして必要なら refresh_token で再セット（10分毎）
const _KEEPALIVE_INTERVAL_MS = 10 * 60 * 1000;
setInterval(async ()=>{
  try{
    const { data } = await supabase.auth.getSession();
    const session = data?.session;
    if(session){
      // session が存在すれば何もしない（Supabase SDK が自動更新する場合もある）
      // ただし最新セッションを local に保存しておく
      try{
        localStorage.setItem(_SESSION_KEY, JSON.stringify({
          access_token: session.access_token,
          refresh_token: session.refresh_token,
          user: session.user
        }));
      }catch(e){ /* ignore */ }
      return;
    }
    // session が null の場合、ローカル保存を試して復元
    const raw = localStorage.getItem(_SESSION_KEY);
    if(raw){
      const saved = JSON.parse(raw);
      if(saved?.access_token && saved?.refresh_token){
        console.log('keepalive: restoring session using saved tokens');
        const { data, error } = await supabase.auth.setSession({
          access_token: saved.access_token,
          refresh_token: saved.refresh_token
        });
        if(error){
          console.warn('keepalive: setSession error', error);
          // 無効なら保存を削除
          try{ localStorage.removeItem(_SESSION_KEY); }catch(e){}
        } else {
          console.log('keepalive: session restored');
        }
      }
    }
  }catch(e){
    console.warn('keepalive err', e);
  }
}, _KEEPALIVE_INTERVAL_MS);

// 3) ページを閉じる時に現在のセッションを確実に保存する（fallback）
window.addEventListener('beforeunload', async ()=>{
  try{
    const { data } = await supabase.auth.getSession();
    const session = data?.session;
    if(session){
      try{
        localStorage.setItem(_SESSION_KEY, JSON.stringify({
          access_token: session.access_token,
          refresh_token: session.refresh_token,
          user: session.user
        }));
      }catch(e){ console.warn('beforeunload save err', e); }
    }
  }catch(e){ /* ignore */ }
});

// 4) parent から送られてくる supabase_session を受け取る既存ハンドラは有効ですが
//    念のためここでもメッセージで即復元できるようにしておきます。
window.addEventListener('message', async (ev) => {
  try{
    const m = ev.data || {};
    if(m && m.type === 'supabase_session' && m.session){
      try{
        await supabase.auth.setSession({
          access_token: m.session.access_token,
          refresh_token: m.session.refresh_token
        });
        // 保存しておく
        localStorage.setItem(_SESSION_KEY, JSON.stringify({
          access_token: m.session.access_token,
          refresh_token: m.session.refresh_token,
          user: m.session.user || null
        }));
        console.log('supabase_session received from parent and set');
      }catch(e){ console.warn('parent session set err', e); }
    }
  }catch(e){}
});


/* --------------------------
   Constants & state
   -------------------------- */
const SEG_MIN = 5, SEG_MS = SEG_MIN * 60000, SEG_H = 60 / SEG_MIN
const STORAGE = 'studio_v4'
const SESSION_KEY = 'supabase_session_v2'
let state = { hourSegments: {}, colors: {}, timer: { running:false, sessionAccumulatedMs:0, _lastTick:null }, _user_saved:false }
let SUBJECTS = [
  { key:'jp', name:'国語', color:'#FF6B6B' },
  { key:'math', name:'数学', color:'#4D9FEE' },
  { key:'sci', name:'理科', color:'#47C88E' },
  { key:'soc', name:'社会', color:'#F6C85F' },
  { key:'en', name:'英語', color:'#9B7BFF' },
]
let sel = SUBJECTS[0].key
let selectedDays = new Set()

/* --------------------------
   DOM refs
   -------------------------- */
const dateInput = document.getElementById('dateInput')
const startTimeInput = document.getElementById('startTimeInput')
const startBtn = document.getElementById('startBtn'), pauseBtn = document.getElementById('pauseBtn'), resetBtn = document.getElementById('resetBtn'), setNowBtn = document.getElementById('setNowBtn')
const hoursGrid = document.getElementById('hoursGrid'), palette = document.getElementById('palette'), legend = document.getElementById('legend')
const elapsedLabel = document.getElementById('elapsedLabel'), todayTotalLabel = document.getElementById('todayTotalLabel')
const authControls = document.getElementById('authControls'), authStatus = document.getElementById('authStatus')
const weeklyList = document.getElementById('weeklyList'), weeklyTotalBox = document.getElementById('weeklyTotalBox'), weeklyTotalLabel = document.getElementById('weeklyTotalLabel')
const openedDays = document.getElementById('openedDays')
const addSubjectBtn = document.getElementById('addSubjectBtn'), newSubjectName = document.getElementById('newSubjectName'), newSubjectColor = document.getElementById('newSubjectColor')
const weeklyChartTarget = document.getElementById('weeklyChart')

/* --------------------------
   Local load/save
   -------------------------- */
function loadLocal(){
  try{
    const raw = localStorage.getItem(STORAGE)
    if(raw){
      const parsed = JSON.parse(raw)
      // shallow merge
      state = Object.assign({}, state, parsed)
    }
  }catch(e){ console.warn('loadLocal', e) }
  // ensure colors for default subjects
  SUBJECTS.forEach(s => { if(!state.colors[s.key]) state.colors[s.key] = s.color })
}
function saveLocal(){ try{ localStorage.setItem(STORAGE, JSON.stringify(state)) }catch(e){ console.warn('saveLocal', e) } }

/* --------------------------
   Session persistence helpers
   -------------------------- */
function saveSessionLocal(session){
  try{
    if(!session){ localStorage.removeItem(SESSION_KEY); return }
    const slim = { access_token: session.access_token, refresh_token: session.refresh_token, user: session.user }
    localStorage.setItem(SESSION_KEY, JSON.stringify(slim))
  }catch(e){ console.warn('saveSessionLocal', e) }
}
async function restoreSessionLocalIfNeeded(){
  try{
    const { data } = await supabase.auth.getSession()
    if(data?.session) return
    const raw = localStorage.getItem(SESSION_KEY)
    if(!raw) return
    const saved = JSON.parse(raw)
    if(saved?.access_token && saved?.refresh_token){
      const { data: setData, error } = await supabase.auth.setSession({ access_token: saved.access_token, refresh_token: saved.refresh_token })
      if(error){ console.warn('setSession error', error); localStorage.removeItem(SESSION_KEY) }
      else console.log('session restored from local')
    }
  }catch(e){ console.warn('restoreSessionLocalIfNeeded', e) }
}
function clearSavedSession(){ try{ localStorage.removeItem(SESSION_KEY) }catch(e){ console.warn(e) } }

/* subscribe auth changes */
supabase.auth.onAuthStateChange(async (event, session) => {
  if(session?.access_token) saveSessionLocal(session)
  else clearSavedSession()

  if(session?.user){
    const role = await fetchRoleForUser(session.user.id)
    renderAuthUI(session.user.email, role)
    authStatus.textContent = `ログイン: ${session.user.email}（${role||'未設定'}）`
    await loadRemoteFor(session.user.id)
  } else {
    renderAuthUI(null)
    authStatus.textContent = '未ログイン（ローカル保存）'
  }
})

/* --------------------------
   helpers
   -------------------------- */
const fmt = ms => {
  if(!ms) return '0:00:00'
  let s = Math.floor(ms/1000), h = Math.floor(s/3600)
  s = s % 3600
  const m = Math.floor(s/60), sec = s%60
  return `${h}:${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}`
}
const ymd = d => `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`
const todayY = ()=> ymd(new Date())
const timeIn = d => `${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`
function ensureDay(dayStr){ if(!state.hourSegments[dayStr]) state.hourSegments[dayStr] = Array.from({length:24}, ()=> Array.from({length:SEG_H}, ()=> ({subject:'', filledMs:0}))) }
function shade(hex, percent){
  const h = hex.replace('#','')
  const r = parseInt(h.substring(0,2),16)
  const g = parseInt(h.substring(2,4),16)
  const b = parseInt(h.substring(4,6),16)
  const t = percent < 0 ? 0 : 255
  const p = Math.abs(percent)/100
  const R = Math.round((t-r)*p)+r
  const G = Math.round((t-g)*p)+g
  const B = Math.round((t-b)*p)+b
  return `rgb(${R}, ${G}, ${B})`
}

/* --------------------------
   Palette & subjects
   -------------------------- */
function buildPalette(){
  palette.innerHTML = ''
  legend.innerHTML = ''
  // ensure SUBJECTS reflected in state.colors
  SUBJECTS.forEach((s, idx) => {
    if(!state.colors[s.key]) state.colors[s.key] = s.color
    // button
    const btn = document.createElement('button')
    btn.className = 'subject-btn'
    btn.dataset.key = s.key
    btn.style.background = state.colors[s.key]
    btn.innerHTML = `<div style="width:14px;height:14px;border-radius:50%;background:${shade(state.colors[s.key],-8)}"></div><div>${s.name}</div>`
    btn.addEventListener('click', ()=>{ sel = s.key; highlightSelected() })
    palette.appendChild(btn)
    // legend item
    const item = document.createElement('div'); item.className='item'
    item.style.display='flex'; item.style.alignItems='center'; item.style.gap='8px'
    const sw = document.createElement('div'); sw.style.width='18px'; sw.style.height='12px'; sw.style.borderRadius='6px'; sw.style.background=state.colors[s.key]
    const lab = document.createElement('div'); lab.textContent = s.name
    const colorInp = document.createElement('input'); colorInp.type='color'; colorInp.value = state.colors[s.key]
    colorInp.addEventListener('input', (e)=>{ state.colors[s.key] = e.target.value; saveLocal(); rebuildColors(); renderAll() })
    item.appendChild(sw); item.appendChild(lab); item.appendChild(colorInp)
    legend.appendChild(item)
  })
  highlightSelected()
}
function rebuildColors(){
  palette.querySelectorAll('.subject-btn').forEach(b=>{
    const k = b.dataset.key
    b.style.background = state.colors[k]
    const dot = b.querySelector('div')
    if(dot) dot.style.background = shade(state.colors[k], -8)
  })
  // update legend sw
  Array.from(legend.querySelectorAll('.item')).forEach((it, idx)=>{
    const sw = it.querySelector('div')
    if(sw && SUBJECTS[idx]) sw.style.background = state.colors[SUBJECTS[idx].key]
    const colorInp = it.querySelector('input[type="color"]')
    if(colorInp && SUBJECTS[idx]) colorInp.value = state.colors[SUBJECTS[idx].key]
  })
}
function highlightSelected(){
  palette.querySelectorAll('.subject-btn').forEach(b=>{
    if(b.dataset.key === sel) b.style.boxShadow = '0 6px 20px rgba(2,6,23,0.12)'
    else b.style.boxShadow = 'none'
  })
}
addSubjectBtn.addEventListener('click', ()=>{
  const name = (newSubjectName.value||'').trim()
  const color = newSubjectColor.value || '#7c3aed'
  if(!name) return alert('教科名を入力してください')
  let key = name.toLowerCase().replace(/[^\w]+/g,'_')
  let base = key, suffix = 1
  while(SUBJECTS.some(s=>s.key === key)){ key = base + '_' + (suffix++) }
  const subj = { key, name, color }
  SUBJECTS.push(subj)
  state.colors[key] = color
  newSubjectName.value = ''
  buildPalette()
  saveLocal()
})

/* --------------------------
   Grid / render
   -------------------------- */
function buildGrid(){
  hoursGrid.innerHTML = ''
  for(let h=0; h<24; h++){
    const col = document.createElement('div'); col.className='hour-col'; col.dataset.hour = h
    const header = document.createElement('div'); header.className='hour-header'; header.textContent = `${h}:00`
    const cell = document.createElement('div'); cell.className='hour-cell'; cell.addEventListener('click', ()=> onHourClick(h))
    col.appendChild(header); col.appendChild(cell); hoursGrid.appendChild(col)
  }
}
function renderCell(dateStr, hour){
  ensureDay(dateStr)
  const segs = state.hourSegments[dateStr][hour]
  const col = hoursGrid.querySelector(`.hour-col[data-hour='${hour}']`)
  if(!col) return
  const cell = col.querySelector('.hour-cell')
  cell.innerHTML = ''
  const wrap = document.createElement('div'); wrap.className='segments'
  for(let i=0;i<SEG_H;i++){
    const s = segs[i]
    const segDiv = document.createElement('div'); segDiv.className='segment'
    const fill = document.createElement('div'); fill.className='fill'
    const pct = Math.max(0, Math.min(1, (s.filledMs||0)/SEG_MS))
    fill.style.width = (pct*100) + '%'
    if(s.subject && state.colors[s.subject]) fill.style.background = `linear-gradient(90deg, ${state.colors[s.subject]}, ${shade(state.colors[s.subject],-8)})`
    segDiv.appendChild(fill); wrap.appendChild(segDiv)
  }
  const label = document.createElement('div'); label.className='cell-label'
  const allSubjs = new Set(segs.map(s=>s.subject||''))
  if(allSubjs.size === 1 && !allSubjs.has('')) label.textContent = SUBJECTS.find(x=>x.key===segs[0].subject)?.name || ''
  const overlay = document.createElement('div'); overlay.className='overlay'
  const totalFilled = segs.reduce((a,b)=>a+(b.filledMs||0),0)
  overlay.textContent = (totalFilled >= 3600000) ? '完了' : ''
  cell.appendChild(wrap); cell.appendChild(label); cell.appendChild(overlay)
}
function renderAll(){
  if(!dateInput.value) dateInput.value = todayY()
  const dateStr = dateInput.value
  ensureDay(dateStr)
  for(let h=0; h<24; h++) renderCell(dateStr,h)
  renderTotals()
  updateButtonStyles()
  saveLocal()
}
function onHourClick(hour){
  const dateStr = dateInput.value
  ensureDay(dateStr)
  const segs = state.hourSegments[dateStr][hour]
  let changed = false
  for(let i=0;i<SEG_H;i++){
    if(segs[i].filledMs === 0 && segs[i].subject !== sel){
      segs[i].subject = sel; changed = true
    }
  }
  if(changed){ scheduleSave(); renderAll() }
}

/* --------------------------
   Timer
   -------------------------- */
function getSegmentStartMs(ts){
  const d = new Date(ts); const dayStart = new Date(d.getFullYear(), d.getMonth(), d.getDate()).getTime()
  const minutesSinceDay = Math.floor((ts - dayStart)/60000)
  const segIndexOverall = Math.floor(minutesSinceDay / SEG_MIN)
  return dayStart + segIndexOverall * SEG_MS
}
function allocateDelta(prevMs, nowMs){
  if(nowMs <= prevMs) return
  let cur = prevMs
  const subject = sel
  while(cur < nowMs){
    const segStart = getSegmentStartMs(cur)
    const segEnd = segStart + SEG_MS
    const addAvailable = Math.min(segEnd, nowMs) - cur
    const d = new Date(segStart)
    const dateStr = ymd(d)
    const hour = d.getHours()
    const minutesSinceHour = Math.floor((segStart - new Date(d.getFullYear(), d.getMonth(), d.getDate(), hour).getTime())/60000)
    const segIndex = Math.floor(minutesSinceHour / SEG_MIN)
    ensureDay(dateStr)
    const seg = state.hourSegments[dateStr][hour][segIndex]
    const before = seg.filledMs || 0
    const canAdd = Math.min(SEG_MS - before, addAvailable)
    if(canAdd > 0){
      if(!seg.subject) seg.subject = subject
      seg.filledMs = before + canAdd
      state.timer.sessionAccumulatedMs = (state.timer.sessionAccumulatedMs || 0) + canAdd
      cur += canAdd
    } else {
      cur = segEnd
    }
  }
}
function tick(){
  const now = Date.now()
  const prev = state.timer._lastTick || now
  allocateDelta(prev, now)
  state.timer._lastTick = now
  updateElapsedDisplay()
  renderAll()
  scheduleSave()
}
function updateElapsedDisplay(){ elapsedLabel.textContent = fmt(state.timer.sessionAccumulatedMs || 0); const dateStr = dateInput.value; ensureDay(dateStr); const todayMs = state.hourSegments[dateStr].reduce((a,h)=>a + h.reduce((aa,seg)=>aa + (seg.filledMs||0),0),0); todayTotalLabel.textContent = fmt(todayMs) }
function startTimer(){ if(state.timer.running) return; state.timer.running = true; state.timer._lastTick = Date.now(); window._tickI = setInterval(tick, 1000); updateButtonStyles(); saveLocal() }
function pauseTimer(){ if(!state.timer.running) return; tick(); state.timer.running = false; clearInterval(window._tickI); state.timer._lastTick = null; updateButtonStyles(); saveLocal() }
function resetTimer(){ if(!confirm('タイマーをリセットします（セッション累積は0に戻ります）。よろしいですか？')) return; state.timer.running = false; clearInterval(window._tickI); state.timer._lastTick = null; state.timer.sessionAccumulatedMs = 0; updateElapsedDisplay(); updateButtonStyles(); saveLocal(); renderAll() }
function onSetNow(){ startTimeInput.value = timeIn(new Date()) }
function updateButtonStyles(){ if(state.timer.running){ startBtn.textContent = '停止'; startBtn.classList.add('running') } else { startBtn.textContent = '開始'; startBtn.classList.remove('running') } }

/* --------------------------
   Totals / weekly / graph
   -------------------------- */
function lastNDates(endDateStr, n){
  const [y,m,d] = endDateStr.split('-').map(x=>parseInt(x,10))
  const end = new Date(y, m-1, d)
  const arr=[]
  for(let i=n-1;i>=0;i--){
    const dd = new Date(end); dd.setDate(end.getDate()-i); arr.push(ymd(dd))
  }
  return arr
}
function weekdayName(dateStr){ const d = new Date(dateStr); return ['日','月','火','水','木','金','土'][d.getDay()] }

function renderTotals(){
  const dateStr = dateInput.value
  ensureDay(dateStr)
  const todayMs = state.hourSegments[dateStr].reduce((a,h)=>a + h.reduce((aa,seg)=>aa + (seg.filledMs||0),0),0)
  todayTotalLabel.textContent = fmt(todayMs)

  const days = lastNDates(dateStr, 7)
  weeklyList.innerHTML = ''
  let weeklyTotalMs = 0
  days.forEach(d=>{
    ensureDay(d)
    const total = state.hourSegments[d].reduce((a,h)=>a + h.reduce((aa,seg)=>aa + (seg.filledMs||0),0),0)
    weeklyTotalMs += total
    const div = document.createElement('div')
    div.style.display='flex'; div.style.justifyContent='space-between'; div.style.padding='6px'; div.style.borderRadius='8px'; div.style.background='#fbfbff'; div.style.cursor='pointer'; div.style.marginBottom='6px'
    const left = document.createElement('div'); left.textContent = `${d} (${weekdayName(d)})`
    const right = document.createElement('div'); right.textContent = fmt(total)
    div.appendChild(left); div.appendChild(right)
    div.addEventListener('click', ()=>{ toggleDay(d, div) })
    if(selectedDays.has(d)) div.style.boxShadow='0 6px 18px rgba(66,97,242,0.04)'
    weeklyList.appendChild(div)
  })
  if(weeklyTotalMs > 0){ weeklyTotalBox.style.display='block'; weeklyTotalLabel.textContent = fmt(weeklyTotalMs) } else { weeklyTotalBox.style.display='none' }
  renderSelected()
  renderWeeklyChart()
}

/* keep selected day panels (optional) */
function toggleDay(d, el){
  if(selectedDays.has(d)){ selectedDays.delete(d); el.style.boxShadow='none' }
  else { selectedDays.add(d); el.style.boxShadow='0 6px 18px rgba(66,97,242,0.04)' }
  renderSelected()
}
function renderSelected(){
  openedDays.innerHTML = ''
  if(selectedDays.size === 0) return
  selectedDays.forEach(d=>{
    ensureDay(d)
    const panel = document.createElement('div'); panel.className='compact-day'
    const header = document.createElement('div'); header.style.display='flex'; header.style.justifyContent='space-between'; header.style.alignItems='center'; header.style.marginBottom='8px'
    const title = document.createElement('div'); title.innerHTML = `<strong>${d} (${weekdayName(d)})</strong>`
    const closeBtn = document.createElement('button'); closeBtn.className='btn ghost'; closeBtn.style.fontSize='12px'; closeBtn.textContent='閉じる'
    closeBtn.onclick = ()=>{ selectedDays.delete(d); renderSelected(); renderTotals() }
    header.appendChild(title); header.appendChild(closeBtn); panel.appendChild(header)
    const grid = document.createElement('div'); grid.className='compact-grid'
    for(let h=0; h<24; h++){
      const hourCol = document.createElement('div'); hourCol.className='compact-hour'
      const hh = document.createElement('div'); hh.className='hour-header'; hh.style.fontSize='12px'; hh.style.marginBottom='6px'; hh.textContent = `${h}:00`
      const cell = document.createElement('div'); cell.className='compact-cell'
      const segWrap = document.createElement('div'); segWrap.style.display='flex'; segWrap.style.height='100%'; segWrap.style.setProperty('--seg-count', SEG_H)
      const segs = state.hourSegments[d][h]
      for(let i=0;i<SEG_H;i++){
        const s = segs[i]; const segDiv = document.createElement('div'); segDiv.style.flex='0 0 calc(100% / '+SEG_H+')'; segDiv.style.position='relative'
        const fill = document.createElement('div'); fill.style.height='100%'; const pct = Math.max(0, Math.min(1, (s.filledMs||0)/SEG_MS))
        if(s.subject && state.colors[s.subject]) fill.style.background = `linear-gradient(90deg, ${state.colors[s.subject]}, ${shade(state.colors[s.subject],-8)})`
        else fill.style.background = 'transparent'
        fill.style.width = (pct*100) + '%'; fill.style.transition='width .2s linear'; segDiv.appendChild(fill); segWrap.appendChild(segDiv)
      }
      cell.appendChild(segWrap); hourCol.appendChild(hh); hourCol.appendChild(cell); grid.appendChild(hourCol)
    }
    panel.appendChild(grid); openedDays.appendChild(panel)
  })
}

/* --------------------------
   Remote persistence (Supabase)
   -------------------------- */
async function saveRemote(){
  try{
    const { data } = await supabase.auth.getSession()
    const session = data?.session
    if(!session || !session.user) return
    const payload = { user_id: session.user.id, data: state.hourSegments }
    const { error } = await supabase.from('user_hours').upsert(payload)
    if(error) console.warn('saveRemote err', error)
    else state._user_saved = true
  }catch(e){ console.warn('saveRemote', e) }
}
let saveTimer = null
function scheduleSave(){ if(saveTimer) clearTimeout(saveTimer); saveTimer = setTimeout(()=>{ saveLocal(); saveRemote() }, 900) }

async function loadRemoteFor(uid){
  try{
    const { data, error } = await supabase.from('user_hours').select('data').eq('user_id', uid).maybeSingle()
    if(error){ console.warn('loadRemoteFor error', error); return }
    if(data && data.data){
      state.hourSegments = data.data
      saveLocal()
      renderAll()
      state._user_saved = true
    }
  }catch(e){ console.warn('loadRemoteFor', e) }
}

/* --------------------------
   Auth UI & flows
   -------------------------- */
function renderAuthUI(email, role){
  authControls.innerHTML = ''
  if(!email){
    const btn = document.createElement('button'); btn.className='btn'; btn.textContent='メールでログイン/登録'; btn.onclick = openEmail; authControls.appendChild(btn)
  } else {
    const t = document.createElement('div'); t.style.fontWeight='700'; t.textContent = email
    const out = document.createElement('button'); out.className='btn ghost'; out.textContent='サインアウト'; out.onclick = signOut
    authControls.appendChild(t); authControls.appendChild(out)
    if(role === 'teacher'){ const a = document.createElement('button'); a.className='btn'; a.textContent='先生メニュー'; a.onclick = ()=> alert('先生メニュー（未実装）'); authControls.appendChild(a) }
  }
}

async function openEmail(){
  const mode = prompt('signup or signin? (例: signup)')
  if(!mode) return
  const email = prompt('メールアドレス')
  if(!email) return alert('メール未入力')
  const password = prompt('パスワード（8文字以上）')
  if(!password) return alert('パスワード未入力')
  if(mode === 'signup'){
    const role = prompt('role (teacher or student)','student') || 'student'
    const { data, error } = await supabase.auth.signUp({ email, password })
    if(error){ alert('登録エラー: ' + error.message); return }
    if(data?.user?.id){
      await supabase.from('user_profiles').upsert({ user_id: data.user.id, role })
    }
    const { data: sessData } = await supabase.auth.getSession()
    if(sessData?.session){ saveSessionLocal(sessData.session); renderAuthUI(sessData.session.user.email, role); authStatus.textContent = `ログイン: ${sessData.session.user.email}`; await loadRemoteFor(sessData.session.user.id) }
    else alert('登録しました。確認メールを確認してください（必要があれば）。')
  } else {
    const { data, error } = await supabase.auth.signInWithPassword({ email, password })
    if(error){ alert('サインイン失敗: ' + error.message); return }
    const session = data?.session
    if(session){
      saveSessionLocal(session)
      const uid = session.user.id
      const rp = await supabase.from('user_profiles').select('role').eq('user_id', uid).maybeSingle()
      const role = rp.data?.role || null
      renderAuthUI(session.user.email, role)
      authStatus.textContent = 'ログイン:' + session.user.email
      await loadRemoteFor(uid)
    } else {
      const { data: g } = await supabase.auth.getSession()
      const s = g?.session
      if(s){ saveSessionLocal(s); const uid = s.user.id; const rp = await supabase.from('user_profiles').select('role').eq('user_id', uid).maybeSingle(); const role = rp.data?.role||null; renderAuthUI(s.user.email,role); authStatus.textContent='ログイン:'+s.user.email; await loadRemoteFor(uid) }
    }
  }
}

async function signOut(){
  try{ await supabase.auth.signOut() }catch(e){ console.warn(e) }
  clearSavedSession()
  renderAuthUI(null)
  authStatus.textContent = 'サインアウト'
}

async function fetchRoleForUser(userId){
  try{
    const { data, error } = await supabase.from('user_profiles').select('role').eq('user_id', userId).maybeSingle()
    if(error){ console.warn('role fetch', error); return null }
    return data?.role || null
  }catch(e){ console.error(e); return null }
}

/* --------------------------
   Weekly chart
   -------------------------- */
function renderWeeklyChart(){
  const chartDiv = document.getElementById('weeklyChart');
  if(!chartDiv) return;
  if(!chartDiv.style.height || chartDiv.style.height === '') chartDiv.style.height = '160px';
  chartDiv.innerHTML = '';

  const days = lastNDates(dateInput.value || todayY(), 7);
  const totals = days.map(d => {
    if(!state.hourSegments[d]) return 0;
    return state.hourSegments[d].reduce((a,h)=>a+h.reduce((aa,s)=>aa + (s.filledMs||0),0),0) / 3600000;
  });

  const containerW = chartDiv.clientWidth;
  const containerH = chartDiv.clientHeight || 160;
  if(containerW === 0){ requestAnimationFrame(()=>{ renderWeeklyChart(); }); return; }

  const margin = { top: 20, right: 12, bottom: 28, left: 12 };
  const w = containerW;
  const h = containerH;
  const innerW = Math.max(10, w - margin.left - margin.right);
  const innerH = Math.max(10, h - margin.top - margin.bottom);

  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS,'svg');
  svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
  svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
  svg.setAttribute('width', '100%');
  svg.setAttribute('height', '100%');
  svg.style.display = 'block';
  svg.innerHTML = '';

  for(let i=0;i<=4;i++){
    const ly = margin.top + i * (innerH / 4);
    const line = document.createElementNS(svgNS,'line');
    line.setAttribute('x1', margin.left);
    line.setAttribute('x2', margin.left + innerW);
    line.setAttribute('y1', ly);
    line.setAttribute('y2', ly);
    line.setAttribute('stroke', 'rgba(15,23,36,0.04)');
    line.setAttribute('stroke-width', '1');
    svg.appendChild(line);
  }

  const n = totals.length;
  const stepX = n > 1 ? innerW / (n-1) : innerW;
  const maxTotal = Math.max(...totals, 1);
  const points = totals.map((t,i)=>{
    const x = Math.round(margin.left + i * stepX);
    const y = Math.round(margin.top + (1 - (t / maxTotal)) * innerH);
    return [x,y];
  });

  const path = document.createElementNS(svgNS,'path');
  const d = points.map((p,i)=> i===0?`M${p[0]} ${p[1]}`:`L${p[0]} ${p[1]}`).join(' ');
  path.setAttribute('d', d);
  path.setAttribute('fill', 'none');
  path.setAttribute('stroke', '#4461f2');
  path.setAttribute('stroke-width', '3');
  path.setAttribute('stroke-linejoin', 'round');
  path.setAttribute('stroke-linecap', 'round');
  svg.appendChild(path);

  try{
    const area = document.createElementNS(svgNS,'path');
    const areaD = `${d} L ${margin.left + innerW} ${margin.top + innerH} L ${margin.left} ${margin.top + innerH} Z`;
    area.setAttribute('d', areaD);
    area.setAttribute('fill', 'rgba(68,97,242,0.06)');
    svg.insertBefore(area, path);
  }catch(e){}

  points.forEach((p,i)=>{
    const circ = document.createElementNS(svgNS,'circle');
    circ.setAttribute('cx', p[0]); circ.setAttribute('cy', p[1]); circ.setAttribute('r', 4); circ.setAttribute('fill', '#4461f2');
    svg.appendChild(circ);

    const tx = document.createElementNS(svgNS,'text');
    tx.setAttribute('x', p[0]); tx.setAttribute('y', h - 6);
    tx.setAttribute('text-anchor','middle'); tx.setAttribute('font-size','11'); tx.setAttribute('fill','#0f1724');
    tx.textContent = days[i].slice(5);
    svg.appendChild(tx);

    const vl = document.createElementNS(svgNS,'text');
    vl.setAttribute('x', p[0]); vl.setAttribute('y', p[1] - 8);
    vl.setAttribute('text-anchor','middle'); vl.setAttribute('font-size','11'); vl.setAttribute('fill','#0f1724');
    vl.textContent = totals[i].toFixed(1) + 'h';
    svg.appendChild(vl);
  });

  chartDiv.appendChild(svg);

  setTimeout(()=>{ reportHeightToParent() }, 60);
}

/* ResizeObserver と高さ通知（1回だけ追加すれば良い） */
let _chartResizeObserver = null;
let _chartResizeDebounce = null;
function observeWeeklyChartResize(){
  const chartDiv = document.getElementById('weeklyChart');
  if(!chartDiv) return;
  if(_chartResizeObserver) _chartResizeObserver.disconnect();
  _chartResizeObserver = new ResizeObserver(entries=>{
    if(_chartResizeDebounce) clearTimeout(_chartResizeDebounce);
    _chartResizeDebounce = setTimeout(()=>{ renderWeeklyChart(); }, 120);
  });
  _chartResizeObserver.observe(chartDiv);
  window.addEventListener('resize', ()=>{ if(_chartResizeDebounce) clearTimeout(_chartResizeDebounce); _chartResizeDebounce = setTimeout(()=>renderWeeklyChart(), 120) });
}
if(document.readyState === 'loading'){
  document.addEventListener('DOMContentLoaded', ()=>{ observeWeeklyChartResize(); renderWeeklyChart(); });
} else { observeWeeklyChartResize(); renderWeeklyChart(); }

function reportHeightToParent(){
  try{
    const body = document.body;
    const html = document.documentElement;
    const height = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
    if(window.parent && window.parent !== window){
      window.parent.postMessage({ type: 'child_height', height: height }, location.origin);
    }
  }catch(e){ console.warn(e) }
}
new MutationObserver(()=>{ setTimeout(reportHeightToParent, 80) }).observe(document.body, { childList:true, subtree:true, attributes:true });

/* --------------------------
   Init
   -------------------------- */
(async function init(){
  loadLocal()
  if(!dateInput.value) dateInput.value = todayY()
  if(!startTimeInput.value) startTimeInput.value = timeIn(new Date())
  buildPalette()
  buildGrid()
  renderAll()
  renderAuthUI(null)

  await restoreSessionLocalIfNeeded()

  try{
    const { data } = await supabase.auth.getSession()
    const session = data?.session
    if(session && session.user){
      const role = await fetchRoleForUser(session.user.id)
      renderAuthUI(session.user.email, role)
      authStatus.textContent = `ログイン: ${session.user.email}`
      await loadRemoteFor(session.user.id)
    } else {
      authStatus.textContent = '未ログイン（ローカル保存）'
    }
  }catch(e){ console.warn('session check', e); authStatus.textContent = '認証チェック失敗' }
})()

/* --------------------------
   Bindings
   -------------------------- */
startBtn.addEventListener('click', ()=> state.timer.running ? pauseTimer() : startTimer())
pauseBtn.addEventListener('click', pauseTimer)
resetBtn.addEventListener('click', resetTimer)
setNowBtn.addEventListener('click', onSetNow)
dateInput.addEventListener('change', ()=> renderAll())

/* End of script */
</script>

<!-- ====== 追加: 自動フィット用スクリプト（デザインは変更しない） ====== -->
<script>
(function(){
  // .fit-viewport-container > .wrap を縮小してビューポートに収める（デザイン規則はそのまま）
  const wrap = document.querySelector('.fit-viewport-container > .wrap');
  if(!wrap) return;

  let fitTimer = null;
  function debounceFit(delay=80){
    if(fitTimer) clearTimeout(fitTimer);
    fitTimer = setTimeout(()=>{ fitToViewport(); fitTimer = null }, delay);
  }

  function fitToViewport(){
    // 一旦 transform をリセットして実サイズを測る
    wrap.style.transform = 'none';
    wrap.style.marginLeft = '';

    // 少し余裕を残す（左右上下の余白を確保）
    const H_PADDING = 36; // 左右合計
    const V_PADDING = 36; // 上下合計

    const availableW = Math.max(100, window.innerWidth - H_PADDING);
    const availableH = Math.max(100, window.innerHeight - V_PADDING);

    const rect = wrap.getBoundingClientRect();
    const contentW = rect.width;
    const contentH = rect.height;

    // 必要なら縮小（拡大はしない）
    const scaleX = availableW / contentW;
    const scaleY = availableH / contentH;
    const scale = Math.min(1, scaleX, scaleY);

    wrap.style.transform = `scale(${scale})`;

    // 横中央に見えるよう margin-left を調整（見た目を中央に寄せる）
    const renderedW = contentW * scale;
    const offsetX = Math.max(0, (window.innerWidth - renderedW) / 2);
    wrap.style.marginLeft = offsetX + 'px';

    // 親フレームへ高さを通知（存在すれば）
    if(typeof reportHeightToParent === 'function'){
      setTimeout(reportHeightToParent, 40);
    }
  }

  // ウィンドウリサイズ・DOM変化を監視して再フィット
  window.addEventListener('resize', ()=> debounceFit(60));
  const mo = new MutationObserver(()=> debounceFit(80));
  mo.observe(wrap, { subtree:true, childList:true, attributes:true, characterData:true });

  // 初回実行
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ()=> setTimeout(fitToViewport, 60));
  } else {
    setTimeout(fitToViewport, 60);
  }

  // デバッグ用に手動トリガを公開
  window.fitAppToViewport = fitToViewport;
})();
</script>
<!-- ====== ここまで ====== -->
<!-- paste this into your iframe HTML (near end of body). Self-contained: loads supabase client and UI. -->
<script type="module">
/*
  FRAME-ONLY StudyLogs loader + session persistence + weekly chart
  - Replaces need for parent.postMessage
  - Allows entering anon key in UI and signing in to persist session
  - Draws weekly chart from study_logs table: columns expected: id,user_id,date,minutes,created_at
*/

import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm';

// CONFIG: change PROJECT_URL only if different. ANON key is entered via UI or localStorage.
const SUPABASE_URL = 'https://pscowkpzgomszpvjtnge.supabase.co';
const STORAGE_KEY_ANON = 'supabase_anon_key_studio_iframe_v1';
const STORAGE_KEY_SESSION = 'supabase_session_v2_iframe_v1';

// small helper DOM
function el(html){ const div = document.createElement('div'); div.innerHTML = html.trim(); return div.firstChild; }
function safeLog(...args){ console.log('[iframe-studylogs]', ...args); }

// ensure basic UI for key input + status
function ensureControlPanel(){
  if(document.getElementById('sd_iframe_ctrl')) return document.getElementById('sd_iframe_ctrl');
  const ctrl = document.createElement('div');
  ctrl.id = 'sd_iframe_ctrl';
  Object.assign(ctrl.style, {
    position: 'fixed', right: '12px', top: '12px', zIndex: 9999,
    background: '#fff', border: '1px solid rgba(15,23,36,0.06)', padding: '8px', borderRadius: '10px',
    boxShadow: '0 8px 28px rgba(2,6,23,0.08)', fontFamily:'Inter, system-ui, sans-serif', fontSize:'13px'
  });
  ctrl.innerHTML = `
    <div style="font-weight:700;margin-bottom:6px">Studio: study_logs</div>
    <div id="sd_status" style="font-size:12px;color:#374151;margin-bottom:6px">status: init</div>
    <div style="display:flex;gap:6px;margin-bottom:6px">
      <input id="sd_key_input" placeholder="Paste anon key" style="width:220px;padding:6px;border-radius:6px;border:1px solid #e5e7eb" />
    </div>
    <div style="display:flex;gap:6px;">
      <button id="sd_key_save" style="padding:6px 8px;border-radius:8px;border:0;background:#4461f2;color:white;cursor:pointer">Save key</button>
      <button id="sd_try_fetch" style="padding:6px 8px;border-radius:8px;border:1px solid #e5e7eb;background:transparent;cursor:pointer">Fetch</button>
    </div>
    <div style="margin-top:8px;font-size:12px">
      <div style="margin-bottom:6px"><strong>Login</strong></div>
      <input id="sd_login_email" placeholder="email" style="width:220px;padding:6px;border-radius:6px;border:1px solid #e5e7eb;margin-bottom:6px" />
      <input id="sd_login_pass" placeholder="password" type="password" style="width:220px;padding:6px;border-radius:6px;border:1px solid #e5e7eb;margin-bottom:6px" />
      <div style="display:flex;gap:6px">
        <button id="sd_login_btn" style="padding:6px 8px;border-radius:8px;border:0;background:#10b981;color:white;cursor:pointer">Sign in</button>
        <button id="sd_logout_btn" style="padding:6px 8px;border-radius:8px;border:1px solid #e5e7eb;background:transparent;cursor:pointer">Sign out</button>
      </div>
    </div>
    <div id="sd_error" style="color:#b91c1c;margin-top:6px;font-size:12px"></div>
  `;
  document.body.appendChild(ctrl);

  // wire buttons
  document.getElementById('sd_key_save').addEventListener('click', ()=>{
    const v = document.getElementById('sd_key_input').value.trim();
    if(!v){ setStatus('No key entered', true); return; }
    localStorage.setItem(STORAGE_KEY_ANON, v);
    setStatus('Saved anon key locally. Re-initializing client...');
    initSupabaseClient(v).then(()=>attemptRestoreAndFetch());
  });
  document.getElementById('sd_try_fetch').addEventListener('click', ()=> attemptRestoreAndFetch(true));
  document.getElementById('sd_login_btn').addEventListener('click', ()=> signIn());
  document.getElementById('sd_logout_btn').addEventListener('click', ()=> signOut());
  return ctrl;
}
function setStatus(msg, isError=false){
  const s = document.getElementById('sd_status') || ensureControlPanel().querySelector('#sd_status');
  s.textContent = 'status: ' + msg;
  s.style.color = isError ? '#b91c1c' : '#374151';
}
function setError(msg){
  const e = document.getElementById('sd_error') || ensureControlPanel().querySelector('#sd_error');
  e.textContent = msg || '';
}

// create weeklyChart if missing
function ensureWeeklyChart(){
  let chart = document.getElementById('weeklyChart');
  if(chart) return chart;
  // try to find .graph-card (your layout) and append
  const graphCard = document.querySelector('.graph-card') || document.querySelector('.wrap') || document.body;
  chart = document.createElement('div');
  chart.id = 'weeklyChart';
  chart.style.width = '100%';
  chart.style.height = '160px';
  chart.style.marginTop = '8px';
  graphCard.appendChild(chart);
  safeLog('created #weeklyChart placeholder');
  return chart;
}

// small helpers
function ymd(d){ return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`; }
function lastNDates(endDateStr, n){
  const [y,m,d] = endDateStr.split('-').map(x=>parseInt(x,10));
  const end = new Date(y, m-1, d);
  const arr=[];
  for(let i=n-1;i>=0;i--){ const dd=new Date(end); dd.setDate(dd.getDate()-i); arr.push( ymd(dd) ); }
  return arr;
}

// draw svg (minutes -> hours)
function renderStudyLogsWeekly(rows, start, end){
  const chartDiv = ensureWeeklyChart();
  chartDiv.innerHTML = '';
  const endDate = end || ymd(new Date());
  const days = lastNDates(endDate, 7);

  const map = {};
  (rows || []).forEach(r=>{
    const date = (r.date || r.created_at || '').slice(0,10);
    const minutes = Number(r.minutes || 0);
    if(!map[date]) map[date] = 0;
    map[date] += (isNaN(minutes) ? 0 : minutes);
  });

  const totalsHours = days.map(d => (map[d] || 0) / 60);

  const w = chartDiv.clientWidth || 320;
  const h = chartDiv.clientHeight || 160;
  const margin = { top: 20, right: 12, bottom: 28, left: 12 };
  const innerW = Math.max(10, w - margin.left - margin.right);
  const innerH = Math.max(10, h - margin.top - margin.bottom);
  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS,'svg');
  svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
  svg.setAttribute('width','100%'); svg.setAttribute('height','100%'); svg.style.display='block';

  for(let i=0;i<=4;i++){
    const ly = margin.top + i * (innerH / 4);
    const line = document.createElementNS(svgNS,'line');
    line.setAttribute('x1', margin.left); line.setAttribute('x2', margin.left + innerW);
    line.setAttribute('y1', ly); line.setAttribute('y2', ly);
    line.setAttribute('stroke', 'rgba(15,23,36,0.04)'); line.setAttribute('stroke-width', '1');
    svg.appendChild(line);
  }

  const n = totalsHours.length;
  const stepX = n > 1 ? innerW / (n-1) : innerW;
  const maxTotal = Math.max(...totalsHours, 1);
  const points = totalsHours.map((t,i)=>{
    const x = Math.round(margin.left + i * stepX);
    const y = Math.round(margin.top + (1 - (t / maxTotal)) * innerH);
    return [x,y];
  });

  const path = document.createElementNS(svgNS,'path');
  const d = points.map((p,i)=> i===0?`M${p[0]} ${p[1]}`:`L${p[0]} ${p[1]}`).join(' ');
  path.setAttribute('d', d); path.setAttribute('fill', 'none');
  path.setAttribute('stroke', '#4461f2'); path.setAttribute('stroke-width', '3');
  path.setAttribute('stroke-linejoin', 'round'); path.setAttribute('stroke-linecap', 'round');
  svg.appendChild(path);

  try{
    const area = document.createElementNS(svgNS,'path');
    const areaD = `${d} L ${margin.left + innerW} ${margin.top + innerH} L ${margin.left} ${margin.top + innerH} Z`;
    area.setAttribute('d', areaD); area.setAttribute('fill', 'rgba(68,97,242,0.06)');
    svg.insertBefore(area, path);
  }catch(e){}

  points.forEach((p,i)=>{
    const circ = document.createElementNS(svgNS,'circle'); circ.setAttribute('cx', p[0]); circ.setAttribute('cy', p[1]); circ.setAttribute('r', 4); circ.setAttribute('fill', '#4461f2'); svg.appendChild(circ);
    const tx = document.createElementNS(svgNS,'text'); tx.setAttribute('x', p[0]); tx.setAttribute('y', h - 6); tx.setAttribute('text-anchor','middle'); tx.setAttribute('font-size','11'); tx.setAttribute('fill','#0f1724'); tx.textContent = days[i].slice(5); svg.appendChild(tx);
    const vl = document.createElementNS(svgNS,'text'); vl.setAttribute('x', p[0]); vl.setAttribute('y', p[1] - 8); vl.setAttribute('text-anchor','middle'); vl.setAttribute('font-size','11'); vl.setAttribute('fill','#0f1724'); vl.textContent = totalsHours[i].toFixed(1) + 'h'; svg.appendChild(vl);
  });

  chartDiv.appendChild(svg);
  safeLog('rendered weekly chart', totalsHours);
}

// Supabase client instance (will be initialized when key available)
let supabase = null;

// Initialize supabase client with anon key
async function initSupabaseClient(maybeKey){
  setError('');
  if(!maybeKey) {
    const stored = localStorage.getItem(STORAGE_KEY_ANON);
    maybeKey = stored || '';
  }
  if(!maybeKey){
    setStatus('No anon key (enter above)', true);
    return false;
  }
  try{
    supabase = createClient(SUPABASE_URL, maybeKey, { auth: { persistSession: false } });
    window.supabase = supabase; // expose to console if helpful
    setStatus('Supabase client initialized (key loaded)');
    // restore session if saved
    const raw = localStorage.getItem(STORAGE_KEY_SESSION);
    if(raw){
      try{
        const sess = JSON.parse(raw);
        if(sess && sess.access_token && sess.refresh_token){
          // set session in client
          const { error } = await supabase.auth.setSession({ access_token: sess.access_token, refresh_token: sess.refresh_token });
          if(error){ safeLog('setSession error', error); } else { setStatus('session restored'); }
        }
      }catch(e){ safeLog('session parse err', e); }
    }
    return true;
  }catch(e){
    setStatus('Failed to init client', true);
    setError(String(e));
    console.error(e);
    return false;
  }
}

// Sign in flow (email/password)
async function signIn(){
  setError('');
  if(!supabase) { setError('Supabase client not initialized'); return; }
  const email = document.getElementById('sd_login_email').value.trim();
  const pass = document.getElementById('sd_login_pass').value;
  if(!email || !pass){ setError('email/password required'); return; }
  setStatus('Signing in...');
  try{
    const { data, error } = await supabase.auth.signInWithPassword({ email, password: pass });
    if(error){ setError('Sign in error: ' + (error.message||error)); setStatus('signed out', true); return; }
    const session = data?.session;
    if(session){
      // save minimal session
      const slim = { access_token: session.access_token, refresh_token: session.refresh_token, user: session.user };
      localStorage.setItem(STORAGE_KEY_SESSION, JSON.stringify(slim));
      setStatus('Signed in: ' + (session.user?.email || session.user?.id));
      safeLog('signed in session saved');
      // try fetch for this user
      await fetchStudyLogsForUser(session.user.id);
    } else {
      setError('No session returned from signIn');
    }
  }catch(e){ setError('Sign in exception: ' + String(e)); setStatus('signed out', true); }
}

// sign out
async function signOut(){
  try{
    if(supabase) await supabase.auth.signOut();
  }catch(e){ safeLog('signOut error', e); }
  localStorage.removeItem(STORAGE_KEY_SESSION);
  setStatus('signed out');
  setError('');
}

// Fetch study_logs using supabase client (filter by uid if provided)
async function fetchStudyLogsForUser(uid){
  setError('');
  if(!supabase){ setError('Client not initialized'); return; }
  const today = new Date();
  const end = ymd(today);
  const start = (()=>{
    const d = new Date(today); d.setDate(d.getDate()-6); return ymd(d);
  })();
  setStatus('Fetching study_logs ' + start + ' → ' + end);
  try{
    let q = supabase.from('study_logs').select('date,minutes,user_id').gte('date', start).lte('date', end).order('date', { ascending: true });
    if(uid) q = q.eq('user_id', uid);
    const { data, error, status } = await q;
    if(error){
      safeLog('supabase fetch error', status, error);
      setError('Fetch error: ' + (error.message || JSON.stringify(error)));
      setStatus('fetch failed', true);
      // if 401/403 show hint
      if(status === 401 || status === 403) setError('Auth error or invalid key (check anon key / RLS).');
      // still render empty chart
      renderStudyLogsWeekly([], start, end);
      return null;
    }
    setStatus('Fetched ' + (Array.isArray(data)?data.length:0) + ' rows');
    renderStudyLogsWeekly(data || [], start, end);
    return data;
  }catch(e){
    console.error('fetch exception', e);
    setError('Fetch exception: ' + String(e));
    setStatus('fetch failed', true);
    renderStudyLogsWeekly([], start, end);
    return null;
  }
}

// fallback: direct REST fetch (in case supabase client not available but anon key provided)
async function fetchViaRestAnon(key){
  setError('');
  const today = new Date();
  const end = ymd(today);
  const d = new Date(today); d.setDate(d.getDate()-6); const start = ymd(d);
  const url = `${SUPABASE_URL}/rest/v1/study_logs?select=date,minutes&date=gte.${start}&date=lte.${end}&order=date.asc`;
  setStatus('REST fetching via anon key');
  try{
    const resp = await fetch(url, { headers: { 'apikey': key, 'Authorization': 'Bearer ' + key }});
    const text = await resp.text();
    if(resp.status >= 400){ setError('REST fetch status ' + resp.status + ': ' + text); setStatus('fetch failed', true); renderStudyLogsWeekly([], start, end); return null; }
    const body = JSON.parse(text);
    setStatus('REST fetched ' + (Array.isArray(body)?body.length:0) + ' rows');
    renderStudyLogsWeekly(body, start, end);
    return body;
  }catch(e){
    setError('REST fetch exception: ' + String(e));
    setStatus('fetch failed', true);
    renderStudyLogsWeekly([], start, end);
    return null;
  }
}

// Attempt restore or init and fetch sequence
async function attemptRestoreAndFetch(force=false){
  setError('');
  ensureControlPanel();
  const keyFromStorage = localStorage.getItem(STORAGE_KEY_ANON) || '';
  const input = document.getElementById('sd_key_input');
  if(input && !input.value && keyFromStorage) input.value = keyFromStorage;

  const keyToUse = (input && input.value.trim()) || keyFromStorage || '';
  if(!keyToUse){
    setStatus('No anon key available — please paste it above', true);
    return;
  }

  // init client
  const ok = await initSupabaseClient(keyToUse);
  if(!ok){
    setError('Failed to init supabase client with provided key');
    // fallback to REST
    await fetchViaRestAnon(keyToUse);
    return;
  }

  // try to get session user
  try{
    const { data } = await supabase.auth.getSession();
    const session = data?.session;
    if(session && session.user){
      setStatus('Session present: ' + (session.user.email || session.user.id));
      // save session minimal for future
      const slim = { access_token: session.access_token, refresh_token: session.refresh_token, user: session.user };
      localStorage.setItem(STORAGE_KEY_SESSION, JSON.stringify(slim));
      await fetchStudyLogsForUser(session.user.id);
      return;
    } else {
      // no session — but we can try public fetch (without user filter)
      setStatus('No session, attempting public fetch');
      const publicData = await fetchStudyLogsForUser(null);
      if(publicData && publicData.length > 0) return;
      // if public fetch returned empty or failed, fallback to REST
      await fetchViaRestAnon(keyToUse);
    }
  }catch(e){
    console.error('attemptRestoreAndFetch err', e);
    setError('Error during restore/fetch: ' + String(e));
  }
}

// startup: mount UI and try to init if key saved
(function startup(){
  ensureControlPanel();
  ensureWeeklyChart();
  const savedKey = localStorage.getItem(STORAGE_KEY_ANON);
  if(savedKey) {
    document.getElementById('sd_key_input').value = savedKey;
    initSupabaseClient(savedKey).then(()=> attemptRestoreAndFetch());
  } else {
    setStatus('Paste anon key above and Save');
  }

  // expose some helpers to console for debugging
  window.__sd_iframe = {
    attemptRestoreAndFetch, initSupabaseClient, fetchStudyLogsForUser, fetchViaRestAnon, renderStudyLogsWeekly, setStatus
  };
})();
</script>

</body>
</html>


